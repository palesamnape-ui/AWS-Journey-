# AWS Challenge Lab: Build Your VPC and Launch a Web Server
<img width="366" height="297" alt="image" src="https://github.com/user-attachments/assets/0d4b811c-a2d1-489e-93e7-1ff351bfbad7" />


## Hey! Welcome to My AWS Lab Journey 

You're looking at the documentation for an AWS Challenge Lab I completed, where I built a complete Virtual Private Cloud from scratch and deployed a web server into it. It was a hands-on exercise that pushed me to understand the fundamentals of cloud networking—subnets, routing, security groups, and multi-tier architectures.

## What I Set Out to Do

The challenge was straightforward but required real execution:

1. **Create a custom VPC** with public and private subnets across multiple Availability Zones
2. **Configure routing** to enable internet connectivity for public resources while keeping private resources isolated
3. **Build security controls** using security groups to allow only HTTP traffic to the web server
4. **Launch an EC2 instance** running Apache web server in the public subnet
5. **Verify the deployment** by accessing the web application from the internet

No shortcuts, no copy-paste solutions—just me, the AWS Console, and a production-grade network to architect from the ground up.

---

## How I Tackled It

### Getting Started: Planning the Network Architecture

First thing I did was fire up the AWS lab environment and opened the VPC console. I had a clear picture of what needed to be built: a VPC with isolated public and private subnets, proper routing tables, NAT gateway for private subnet internet access, and all the connectivity pieces that make a secure, functional network.

**Figure 1: AWS VPC dashboard ready for configuration**


<img width="1227" height="448" alt="image" src="https://github.com/user-attachments/assets/cdea91bd-4431-4050-b27c-eb01aef43ff2" />

### Building the Foundation: Creating the VPC

I used the VPC Wizard to create the core infrastructure. This wasn't just clicking "next"—I made deliberate networking decisions: 10.0.0.0/16 for the VPC CIDR block, public subnet at 10.0.0.0/24, private subnet at 10.0.1.0/24, all in a single Availability Zone initially. The wizard also provisioned an Internet Gateway for public internet access and a NAT Gateway so private subnet resources could initiate outbound connections.

Here's what the initial build created:
- Lab VPC with 10.0.0.0/16 address space
- Public Subnet 1 (10.0.0.0/24) with route to Internet Gateway
- Private Subnet 1 (10.0.1.0/24) with route to NAT Gateway
- Public and Private Route Tables with appropriate routes
- Internet Gateway and NAT Gateway for connectivity

Nothing fancy, just solid network fundamentals executed correctly.

**Figure 2: VPC Wizard configuration with network topology preview**

<img width="993" height="425" alt="image" src="https://github.com/user-attachments/assets/e3774a18-5b64-4e85-b048-e53f7e500c95" />

**Figure 3: Successfully created VPC with all components**

<img width="975" height="426" alt="image" src="https://github.com/user-attachments/assets/03f51ced-82e4-40f1-b31c-ab14e21d1c88" />

### Expanding for High Availability: Adding More Subnets

Now came the high availability work. A single Availability Zone is a single point of failure—unacceptable for production. I manually created two additional subnets in a second Availability Zone: Public Subnet 2 (10.0.2.0/24) and Private Subnet 2 (10.0.3.0/24). This gives the architecture the ability to survive an entire datacenter failure.

**Figure 4: Creating additional subnets for multi-AZ deployment**

<img width="985" height="440" alt="image" src="https://github.com/user-attachments/assets/d86e1077-1772-4452-9bce-cd0e9dc1d3a2" />
AND
<img width="1001" height="441" alt="image" src="https://github.com/user-attachments/assets/e633a29d-a726-4de9-b235-9f1d5b6529e5" />
AND
<img width="998" height="438" alt="image" src="https://github.com/user-attachments/assets/49139925-7957-4fe8-a4ea-41b636d3fadf" />
AND
<img width="991" height="420" alt="image" src="https://github.com/user-attachments/assets/ed5eb91d-06b4-4439-ad0c-120ee5dc0077" />
AND
<img width="994" height="430" alt="image" src="https://github.com/user-attachments/assets/840df9fe-5365-423e-a044-92a9e7f5904c" />





### Connecting the Pieces: Route Table Associations

Subnets don't automatically know how to route traffic—that's where route tables come in. I associated Public Subnet 2 with the Public Route Table (which routes 0.0.0.0/0 to the Internet Gateway) and Private Subnet 2 with the Private Route Table (which routes 0.0.0.0/0 to the NAT Gateway). Now all four subnets had proper routing configured.

**Figure 5: Route table associations for public subnets**
<img width="1005" height="436" alt="image" src="https://github.com/user-attachments/assets/cdb14795-238a-421b-9c0c-37b2575e5dc2" />
AND
<img width="993" height="419" alt="image" src="https://github.com/user-attachments/assets/4f73d4d7-aa46-41a5-b11b-426386a2af6f" />



### Security Layer: Creating the Security Group

Before launching any instances, I needed proper firewall rules. I created the "Web Security Group" with a single inbound rule: allow HTTP (port 80) from anywhere (0.0.0.0/0). This is the minimum access needed for a public web server—everything else is denied by default. Security groups are stateful, so return traffic is automatically allowed.

**Figure 6: Web Security Group configuration**
<img width="840" height="378" alt="image" src="https://github.com/user-attachments/assets/ec95f6fc-b2a0-4455-8a6d-727b8a1e18d3" />
AND
<img width="990" height="429" alt="image" src="https://github.com/user-attachments/assets/7a8a93d5-c530-4551-a111-cfd038ebaf5c" />



### The Main Event: Launching the Web Server

With networking and security in place, I launched an EC2 instance. I chose Amazon Linux 2, t3.micro instance type, placed it in Public Subnet 2, enabled auto-assign public IP, and associated it with the Web Security Group. The critical piece was the User Data script—bash commands that automatically install Apache, PHP, MySQL client, download the application code, and start the web server. The instance became a fully functional web server without any manual configuration.

**Figure 7: EC2 instance launch configuration**

<img width="990" height="429" alt="image" src="https://github.com/user-attachments/assets/1bef9461-e434-4e88-9e9f-087f6f7468e9" />


**Figure 8: User Data script for automated web server setup**
<img width="995" height="438" alt="image" src="https://github.com/user-attachments/assets/b579a6e4-7c14-4497-9892-abd791492e94" />



### The Moment of Truth: Testing the Web Server

I waited for the instance to pass both status checks (instance health and system health), then grabbed the public IPv4 DNS name from the instance details. Pasted it into a browser, hit Enter, and there it was—the web application loaded perfectly. The entire network architecture was functioning exactly as designed.

**Figure 9: EC2 instance running and healthy**

<img width="1003" height="438" alt="image" src="https://github.com/user-attachments/assets/16e8151c-83cd-4ecb-b9f2-f3af4d0cf3d0" />



**Figure 10: Successfully accessing the web application**
<img width="1003" height="438" alt="image" src="https://github.com/user-attachments/assets/5c31bdb7-fc2e-464f-932d-36c69fd4f03c" />


---

## What I Learned

This wasn't just about launching a web server. The real value was in:

- **Network Architecture Fundamentals** - I learned how VPCs, subnets, route tables, and gateways work together to create isolated, secure networks
- **CIDR Block Planning** - I gained hands-on experience designing IP address spaces and subnet ranges without conflicts
- **Security Group Design** - I understood how to implement least-privilege access using stateful firewall rules
- **High Availability Principles** - I saw how distributing resources across multiple Availability Zones provides fault tolerance
- **Infrastructure Automation** - I used User Data scripts to automate instance configuration, making deployments repeatable and consistent

It's one thing to read about networking concepts. It's another to architect a complete VPC from scratch, make every routing and security decision, and see it work end-to-end.

---

## Repository Contents

```
.
├── images/                           # Screenshots documenting the process
│   ├── aws-banner.png
│   ├── vpc-dashboard.png
│   ├── vpc-creation.png
│   ├── vpc-created.png
│   ├── additional-subnets.png
│   ├── route-table-associations.png
│   ├── security-group.png
│   ├── ec2-launch.png
│   ├── user-data-script.png
│   ├── instance-running.png
│   └── web-application.png
├── architecture-diagrams/            # Network architecture visuals
│   ├── initial-architecture.png
│   └── final-architecture.png
├── user-data-script.sh               # EC2 User Data for web server setup
└── README.md                         # You're reading it
```

---

## Network Architecture Details

### VPC Configuration
- **CIDR Block:** 10.0.0.0/16 (65,536 IP addresses)
- **Availability Zones:** 2 (for high availability)

### Subnets
- **Public Subnet 1:** 10.0.0.0/24 (AZ-1)
- **Public Subnet 2:** 10.0.2.0/24 (AZ-2)
- **Private Subnet 1:** 10.0.1.0/24 (AZ-1)
- **Private Subnet 2:** 10.0.3.0/24 (AZ-2)

### Routing
- **Public Route Table:** Routes 0.0.0.0/0 → Internet Gateway
- **Private Route Table:** Routes 0.0.0.0/0 → NAT Gateway

### Security
- **Web Security Group:** Allow inbound HTTP (port 80) from anywhere

---

## Want to Try This Yourself?

If you have access to AWS and want to replicate this:

1. Use the VPC Wizard to create your VPC with initial public/private subnets
2. Create additional subnets in a second Availability Zone for redundancy
3. Configure route table associations for proper traffic routing
4. Create a security group allowing HTTP traffic
5. Launch an EC2 instance with User Data script to automate web server setup
6. Test by accessing the instance's public DNS name

It's a foundational exercise, but it builds real cloud networking muscle.

---

## Tech Stack

- **Cloud Platform:** AWS (VPC, EC2, Internet Gateway, NAT Gateway)
- **Networking:** Custom VPC, Multiple Subnets, Route Tables, Security Groups
- **Compute:** Amazon EC2 (t3.micro, Amazon Linux 2)
- **Web Server:** Apache HTTP Server
- **Configuration:** User Data automation scripts

---

## User Data Script

```bash
#!/bin/bash
# Install Apache Web Server and PHP
yum install -y httpd mysql php

# Download Lab files
wget https://aws-tc-largeobjects.s3.us-west-2.amazonaws.com/CUR-TF-100-RESTRT-1/267-lab-NF-build-vpc-web-server/s3/lab-app.zip
unzip lab-app.zip -d /var/www/html/

# Turn on web server
chkconfig httpd on
service httpd start
```

---

*Completed as part of AWS Training & Certification Challenge Lab*


